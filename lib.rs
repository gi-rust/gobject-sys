// This file was generated by grust-gen 0.1.0

#![crate_name = "gobject_2_0_sys"]
#![crate_type = "lib"]

extern crate gtypes;
extern crate glib_2_0_sys as glib;

use gtypes::*;


#[repr(C)]
pub struct GClosure {
    // A group of bit fields in the original definition here
    flags: u32,
    marshal: Option<extern "C" fn (closure: *mut GClosure,
                                   return_value: *mut GValue,
                                   n_param_values: guint,
                                   param_values: *const GValue,
                                   invocation_hint: gpointer,
                                   marshal_data: gpointer)>,
    pub data: gpointer,
    notifiers: *mut GClosureNotifyData
}

#[repr(C)]
pub struct GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    // Two single-bit fields in the C definition here
    flags: u8
}

#[repr(C)]
pub struct GTypeCValue(i64);

#[repr(C)]
pub struct GWeakRef(gpointer);

#[repr(C)]
pub struct GValue {
    pub g_type: GType,
    data: [u64; 2]
}


pub type GSignalCMarshaller = GClosureMarshal;

pub type GBaseFinalizeFunc = extern "C" fn (gpointer);

pub type GBaseInitFunc = extern "C" fn (gpointer);

pub enum GBinding { }

#[repr(C)]
pub enum GBindingFlags {
    Default = 0,
    Bidirectional = 1,
    SyncCreate = 2,
    InvertBoolean = 4,
}
pub const G_BINDING_DEFAULT: guint = 0;
pub const G_BINDING_BIDIRECTIONAL: guint = 1;
pub const G_BINDING_SYNC_CREATE: guint = 2;
pub const G_BINDING_INVERT_BOOLEAN: guint = 4;

pub type GBindingTransformFunc = extern "C" fn (*mut GBinding, *const GValue, *mut GValue, gpointer) -> gboolean;

pub type GBoxedCopyFunc = extern "C" fn (gpointer) -> gpointer;

pub type GBoxedFreeFunc = extern "C" fn (gpointer);

#[repr(C)]
pub struct GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}

pub type GCallback = extern "C" fn ();

pub type GClassFinalizeFunc = extern "C" fn (gpointer, gpointer);

pub type GClassInitFunc = extern "C" fn (gpointer, gpointer);

pub type GClosureMarshal = extern "C" fn (*mut GClosure, *mut GValue, guint, *mut GValue, gpointer, gpointer);

pub type GClosureNotify = extern "C" fn (gpointer, *mut GClosure);

#[repr(C)]
pub struct GClosureNotifyData {
    pub data: gpointer,
    pub notify: Option<GClosureNotify>,
}

#[repr(C)]
pub enum GConnectFlags {
    After = 1,
    Swapped = 2,
}
pub const G_CONNECT_AFTER: guint = 1;
pub const G_CONNECT_SWAPPED: guint = 2;

#[repr(C)]
pub struct GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}

#[repr(C)]
pub struct GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}

#[repr(C)]
pub struct GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}

#[repr(C)]
pub struct GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}

#[repr(C)]
pub struct GInitiallyUnowned {
    pub g_type_instance: GTypeInstance,
    ref_count: guint,
    qdata: *mut glib::GData,
}

#[repr(C)]
pub struct GInitiallyUnownedClass {
    pub g_type_class: GTypeClass,
    construct_properties: *mut glib::GSList,
    pub constructor: Option<extern "C" fn (GType, guint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property: Option<extern "C" fn (*mut GObject, guint, *const GValue, *mut GParamSpec)>,
    pub get_property: Option<extern "C" fn (*mut GObject, guint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<extern "C" fn (*mut GObject)>,
    pub finalize: Option<extern "C" fn (*mut GObject)>,
    pub dispatch_properties_changed: Option<extern "C" fn (*mut GObject, guint, *mut *mut GParamSpec)>,
    pub notify: Option<extern "C" fn (*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<extern "C" fn (*mut GObject)>,
    flags: gsize,
    pdummy: [gpointer; 6],
}

pub type GInstanceInitFunc = extern "C" fn (*mut GTypeInstance, gpointer);

pub type GInterfaceFinalizeFunc = extern "C" fn (gpointer, gpointer);

#[repr(C)]
pub struct GInterfaceInfo {
    pub interface_init: Option<GInterfaceInitFunc>,
    pub interface_finalize: Option<GInterfaceFinalizeFunc>,
    pub interface_data: gpointer,
}

pub type GInterfaceInitFunc = extern "C" fn (gpointer, gpointer);

#[repr(C)]
pub struct GObject {
    pub g_type_instance: GTypeInstance,
    ref_count: guint,
    qdata: *mut glib::GData,
}

#[repr(C)]
pub struct GObjectClass {
    pub g_type_class: GTypeClass,
    construct_properties: *mut glib::GSList,
    pub constructor: Option<extern "C" fn (GType, guint, *mut GObjectConstructParam) -> *mut GObject>,
    pub set_property: Option<extern "C" fn (*mut GObject, guint, *const GValue, *mut GParamSpec)>,
    pub get_property: Option<extern "C" fn (*mut GObject, guint, *mut GValue, *mut GParamSpec)>,
    pub dispose: Option<extern "C" fn (*mut GObject)>,
    pub finalize: Option<extern "C" fn (*mut GObject)>,
    pub dispatch_properties_changed: Option<extern "C" fn (*mut GObject, guint, *mut *mut GParamSpec)>,
    pub notify: Option<extern "C" fn (*mut GObject, *mut GParamSpec)>,
    pub constructed: Option<extern "C" fn (*mut GObject)>,
    flags: gsize,
    pdummy: [gpointer; 6],
}

#[repr(C)]
pub struct GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}

pub type GObjectFinalizeFunc = extern "C" fn (*mut GObject);

pub type GObjectGetPropertyFunc = extern "C" fn (*mut GObject, guint, *mut GValue, *mut GParamSpec);

pub type GObjectSetPropertyFunc = extern "C" fn (*mut GObject, guint, *const GValue, *mut GParamSpec);

pub const G_PARAM_MASK: gint = 255;

pub const G_PARAM_STATIC_STRINGS: gint = 0;

pub const G_PARAM_USER_SHIFT: gint = 8;

#[repr(C)]
pub enum GParamFlags {
    Readable = 1,
    Writable = 2,
    Readwrite = 3,
    Construct = 4,
    ConstructOnly = 8,
    LaxValidation = 16,
    StaticName = 32,
    StaticNick = 64,
    StaticBlurb = 128,
    ExplicitNotify = 1073741824,
    Deprecated = 2147483648,
}
pub const G_PARAM_READABLE: guint = 1;
pub const G_PARAM_WRITABLE: guint = 2;
pub const G_PARAM_READWRITE: guint = 3;
pub const G_PARAM_CONSTRUCT: guint = 4;
pub const G_PARAM_CONSTRUCT_ONLY: guint = 8;
pub const G_PARAM_LAX_VALIDATION: guint = 16;
pub const G_PARAM_STATIC_NAME: guint = 32;
pub const G_PARAM_PRIVATE: guint = 32;
pub const G_PARAM_STATIC_NICK: guint = 64;
pub const G_PARAM_STATIC_BLURB: guint = 128;
pub const G_PARAM_EXPLICIT_NOTIFY: guint = 1073741824;
pub const G_PARAM_DEPRECATED: guint = 2147483648;

#[repr(C)]
pub struct GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    _nick: *mut gchar,
    _blurb: *mut gchar,
    qdata: *mut glib::GData,
    ref_count: guint,
    param_id: guint,
}

#[repr(C)]
pub struct GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}

#[repr(C)]
pub struct GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: i8,
    pub maximum: i8,
    pub default_value: i8,
}

#[repr(C)]
pub struct GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: Option<extern "C" fn (*mut GParamSpec)>,
    pub value_set_default: Option<extern "C" fn (*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<extern "C" fn (*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp: Option<extern "C" fn (*mut GParamSpec, *const GValue, *const GValue) -> gint>,
    dummy: [gpointer; 4],
}

#[repr(C)]
pub struct GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}

#[repr(C)]
pub struct GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}

#[repr(C)]
pub struct GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}

#[repr(C)]
pub struct GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}

#[repr(C)]
pub struct GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}

#[repr(C)]
pub struct GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}

#[repr(C)]
pub struct GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: i64,
    pub maximum: i64,
    pub default_value: i64,
}

#[repr(C)]
pub struct GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}

#[repr(C)]
pub struct GParamSpecObject {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecOverride {
    parent_instance: GParamSpec,
    overridden: *mut GParamSpec,
}

#[repr(C)]
pub struct GParamSpecParam {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecPointer {
    pub parent_instance: GParamSpec,
}

#[repr(C)]
pub struct GParamSpecPool(gpointer);

#[repr(C)]
pub struct GParamSpecTypeInfo {
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: Option<extern "C" fn (*mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: Option<extern "C" fn (*mut GParamSpec)>,
    pub value_set_default: Option<extern "C" fn (*mut GParamSpec, *mut GValue)>,
    pub value_validate: Option<extern "C" fn (*mut GParamSpec, *mut GValue) -> gboolean>,
    pub values_cmp: Option<extern "C" fn (*mut GParamSpec, *const GValue, *const GValue) -> gint>,
}

#[repr(C)]
pub struct GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: u8,
    pub maximum: u8,
    pub default_value: u8,
}

#[repr(C)]
pub struct GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}

#[repr(C)]
pub struct GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: u64,
    pub maximum: u64,
    pub default_value: u64,
}

#[repr(C)]
pub struct GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}

#[repr(C)]
pub struct GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}

#[repr(C)]
pub struct GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}

#[repr(C)]
pub struct GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut glib::GVariantType,
    pub default_value: *mut glib::GVariant,
    padding: [gpointer; 4],
}

#[repr(C)]
pub struct GParameter {
    pub name: *const gchar,
    pub value: GValue,
}

pub const G_SIGNAL_FLAGS_MASK: gint = 511;

pub const G_SIGNAL_MATCH_MASK: gint = 63;

pub type GSignalAccumulator = extern "C" fn (*mut GSignalInvocationHint, *mut GValue, *const GValue, gpointer) -> gboolean;

pub type GSignalEmissionHook = extern "C" fn (*mut GSignalInvocationHint, guint, *mut GValue, gpointer) -> gboolean;

#[repr(C)]
pub enum GSignalFlags {
    RunFirst = 1,
    RunLast = 2,
    RunCleanup = 4,
    NoRecurse = 8,
    Detailed = 16,
    Action = 32,
    NoHooks = 64,
    MustCollect = 128,
    Deprecated = 256,
}
pub const G_SIGNAL_RUN_FIRST: guint = 1;
pub const G_SIGNAL_RUN_LAST: guint = 2;
pub const G_SIGNAL_RUN_CLEANUP: guint = 4;
pub const G_SIGNAL_NO_RECURSE: guint = 8;
pub const G_SIGNAL_DETAILED: guint = 16;
pub const G_SIGNAL_ACTION: guint = 32;
pub const G_SIGNAL_NO_HOOKS: guint = 64;
pub const G_SIGNAL_MUST_COLLECT: guint = 128;
pub const G_SIGNAL_DEPRECATED: guint = 256;

#[repr(C)]
pub struct GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: glib::GQuark,
    pub run_type: GSignalFlags,
}

#[repr(C)]
pub enum GSignalMatchType {
    Id = 1,
    Detail = 2,
    Closure = 4,
    Func = 8,
    Data = 16,
    Unblocked = 32,
}
pub const G_SIGNAL_MATCH_ID: guint = 1;
pub const G_SIGNAL_MATCH_DETAIL: guint = 2;
pub const G_SIGNAL_MATCH_CLOSURE: guint = 4;
pub const G_SIGNAL_MATCH_FUNC: guint = 8;
pub const G_SIGNAL_MATCH_DATA: guint = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED: guint = 32;

#[repr(C)]
pub struct GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *mut GType,
}

pub const G_TYPE_FLAG_RESERVED_ID_BIT: GType = 1;

pub const G_TYPE_FUNDAMENTAL_MAX: gint = 255;

pub const G_TYPE_FUNDAMENTAL_SHIFT: gint = 2;

pub const G_TYPE_RESERVED_BSE_FIRST: gint = 32;

pub const G_TYPE_RESERVED_BSE_LAST: gint = 48;

pub const G_TYPE_RESERVED_GLIB_FIRST: gint = 22;

pub const G_TYPE_RESERVED_GLIB_LAST: gint = 31;

pub const G_TYPE_RESERVED_USER_FIRST: gint = 49;

pub type GToggleNotify = extern "C" fn (gpointer, *mut GObject, gboolean);

#[repr(C)]
pub struct GTypeClass {
    g_type: GType,
}

pub type GTypeClassCacheFunc = extern "C" fn (gpointer, *mut GTypeClass) -> gboolean;

#[repr(C)]
pub enum GTypeDebugFlags {
    None = 0,
    Objects = 1,
    Signals = 2,
    InstanceCount = 4,
    Mask = 7,
}
pub const G_TYPE_DEBUG_NONE: guint = 0;
pub const G_TYPE_DEBUG_OBJECTS: guint = 1;
pub const G_TYPE_DEBUG_SIGNALS: guint = 2;
pub const G_TYPE_DEBUG_INSTANCE_COUNT: guint = 4;
pub const G_TYPE_DEBUG_MASK: guint = 7;

#[repr(C)]
pub enum GTypeFlags {
    Abstract = 16,
    ValueAbstract = 32,
}
pub const G_TYPE_FLAG_ABSTRACT: guint = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT: guint = 32;

#[repr(C)]
pub enum GTypeFundamentalFlags {
    Classed = 1,
    Instantiatable = 2,
    Derivable = 4,
    DeepDerivable = 8,
}
pub const G_TYPE_FLAG_CLASSED: guint = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE: guint = 2;
pub const G_TYPE_FLAG_DERIVABLE: guint = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE: guint = 8;

#[repr(C)]
pub struct GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}

#[repr(C)]
pub struct GTypeInfo {
    pub class_size: u16,
    pub base_init: Option<GBaseInitFunc>,
    pub base_finalize: Option<GBaseFinalizeFunc>,
    pub class_init: Option<GClassInitFunc>,
    pub class_finalize: Option<GClassFinalizeFunc>,
    pub class_data: gconstpointer,
    pub instance_size: u16,
    pub n_preallocs: u16,
    pub instance_init: Option<GInstanceInitFunc>,
    pub value_table: *const GTypeValueTable,
}

#[repr(C)]
pub struct GTypeInstance {
    g_class: *mut GTypeClass,
}

#[repr(C)]
pub struct GTypeInterface {
    g_type: GType,
    g_instance_type: GType,
}

pub type GTypeInterfaceCheckFunc = extern "C" fn (gpointer, gpointer);

#[repr(C)]
pub struct GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut glib::GSList,
    pub interface_infos: *mut glib::GSList,
    pub name: *mut gchar,
}

#[repr(C)]
pub struct GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: Option<extern "C" fn (*mut GTypeModule) -> gboolean>,
    pub unload: Option<extern "C" fn (*mut GTypeModule)>,
    pub reserved1: Option<extern "C" fn ()>,
    pub reserved2: Option<extern "C" fn ()>,
    pub reserved3: Option<extern "C" fn ()>,
    pub reserved4: Option<extern "C" fn ()>,
}

pub enum GTypePlugin { }

#[repr(C)]
pub struct GTypePluginClass {
    base_iface: GTypeInterface,
    pub use_plugin: Option<GTypePluginUse>,
    pub unuse_plugin: Option<GTypePluginUnuse>,
    pub complete_type_info: Option<GTypePluginCompleteTypeInfo>,
    pub complete_interface_info: Option<GTypePluginCompleteInterfaceInfo>,
}

pub type GTypePluginCompleteInterfaceInfo = extern "C" fn (*mut GTypePlugin, GType, GType, *mut GInterfaceInfo);

pub type GTypePluginCompleteTypeInfo = extern "C" fn (*mut GTypePlugin, GType, *mut GTypeInfo, *mut GTypeValueTable);

pub type GTypePluginUnuse = extern "C" fn (*mut GTypePlugin);

pub type GTypePluginUse = extern "C" fn (*mut GTypePlugin);

#[repr(C)]
pub struct GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}

#[repr(C)]
pub struct GTypeValueTable {
    pub value_init: Option<extern "C" fn (*mut GValue)>,
    pub value_free: Option<extern "C" fn (*mut GValue)>,
    pub value_copy: Option<extern "C" fn (*const GValue, *mut GValue)>,
    pub value_peek_pointer: Option<extern "C" fn (*const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: Option<extern "C" fn (*mut GValue, guint, *mut GTypeCValue, guint) -> *mut gchar>,
    pub lcopy_format: *const gchar,
    pub lcopy_value: Option<extern "C" fn (*const GValue, guint, *mut GTypeCValue, guint) -> *mut gchar>,
}

pub const G_VALUE_COLLECT_FORMAT_MAX_LENGTH: gint = 8;

pub const G_VALUE_NOCOPY_CONTENTS: gint = 134217728;

#[repr(C)]
pub struct GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    n_prealloced: guint,
}

pub type GValueTransform = extern "C" fn (*const GValue, *mut GValue);

pub type GWeakNotify = extern "C" fn (gpointer, *mut GObject);

// GType functions for GLib
extern {
    pub fn g_array_get_type() -> GType;
    pub fn g_byte_array_get_type() -> GType;
    pub fn g_bytes_get_type() -> GType;
    pub fn g_checksum_get_type() -> GType;
    pub fn g_date_get_type() -> GType;
    pub fn g_date_time_get_type() -> GType;
    pub fn g_error_get_type() -> GType;
    pub fn g_gstring_get_type() -> GType;
    pub fn g_hash_table_get_type() -> GType;
    pub fn g_io_channel_get_type() -> GType;
    pub fn g_io_condition_get_type() -> GType;
    pub fn g_key_file_get_type() -> GType;
    pub fn g_main_context_get_type() -> GType;
    pub fn g_main_loop_get_type() -> GType;
    pub fn g_mapped_file_get_type() -> GType;
    pub fn g_markup_parse_context_get_type() -> GType;
    pub fn g_match_info_get_type() -> GType;
    pub fn g_option_group_get_type() -> GType;
    pub fn g_pollfd_get_type() -> GType;
    pub fn g_ptr_array_get_type() -> GType;
    pub fn g_regex_get_type() -> GType;
    pub fn g_source_get_type() -> GType;
    pub fn g_strv_get_type() -> GType;
    pub fn g_thread_get_type() -> GType;
    pub fn g_time_zone_get_type() -> GType;
    pub fn g_variant_builder_get_type() -> GType;
    pub fn g_variant_dict_get_type() -> GType;
    pub fn g_variant_get_gtype() -> GType;
    pub fn g_variant_type_get_gtype() -> GType;
}

// GType functions
extern {
    pub fn g_binding_flags_get_type() -> GType;
    pub fn g_binding_get_type() -> GType;
    pub fn g_closure_get_type() -> GType;
    pub fn g_gtype_get_type() -> GType;
    pub fn g_initially_unowned_get_type() -> GType;
    pub fn g_object_get_type() -> GType;
    pub fn g_type_module_get_type() -> GType;
    pub fn g_type_plugin_get_type() -> GType;
    pub fn g_value_array_get_type() -> GType;
    pub fn g_value_get_type() -> GType;
}

extern {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
    pub fn g_binding_unbind(binding: *mut GBinding);
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
    pub fn g_boxed_type_register_static(name: *const gchar, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) -> GType;
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOOLEAN(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__BOXED(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__CHAR(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__DOUBLE(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ENUM(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLAGS(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__FLOAT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__INT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__LONG(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__OBJECT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__PARAM(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__STRING(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UCHAR(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__ULONG(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VARIANT(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_VOID__VOID(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_marshal_generic(closure: *mut GClosure, return_gvalue: *mut GValue, n_param_values: guint, param_values: *const GValue, invocation_hint: gpointer, marshal_data: gpointer);
    pub fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_object_swap(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
    pub fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) -> *mut GClosure;
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
    pub fn g_closure_add_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_add_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_add_marshal_guards(closure: *mut GClosure, pre_marshal_data: gpointer, pre_marshal_notify: GClosureNotify, post_marshal_data: gpointer, post_marshal_notify: GClosureNotify);
    pub fn g_closure_invalidate(closure: *mut GClosure);
    pub fn g_closure_invoke(closure: *mut GClosure, return_value: *mut GValue, n_param_values: guint, param_values: *mut GValue, invocation_hint: gpointer);
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
    pub fn g_closure_remove_finalize_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_remove_invalidate_notifier(closure: *mut GClosure, notify_data: gpointer, notify_func: GClosureNotify);
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
    pub fn g_closure_set_meta_marshal(closure: *mut GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal);
    pub fn g_closure_sink(closure: *mut GClosure);
    pub fn g_closure_unref(closure: *mut GClosure);
    pub fn g_enum_complete_type_info(g_enum_type: GType, info: GTypeInfo, const_values: *const GEnumValue);
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_name(enum_class: *mut GEnumClass, name: *const gchar) -> *mut GEnumValue;
    pub fn g_enum_get_value_by_nick(enum_class: *mut GEnumClass, nick: *const gchar) -> *mut GEnumValue;
    pub fn g_enum_register_static(name: *const gchar, const_static_values: *const GEnumValue) -> GType;
    pub fn g_flags_complete_type_info(g_flags_type: GType, info: GTypeInfo, const_values: *const GFlagsValue);
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_name(flags_class: *mut GFlagsClass, name: *const gchar) -> *mut GFlagsValue;
    pub fn g_flags_get_value_by_nick(flags_class: *mut GFlagsClass, nick: *const gchar) -> *mut GFlagsValue;
    pub fn g_flags_register_static(name: *const gchar, const_static_values: *const GFlagsValue) -> GType;
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: gpointer);
    pub fn g_object_bind_property(source: gpointer, source_property: *const gchar, target: gpointer, target_property: *const gchar, flags: GBindingFlags) -> *mut GBinding;
    pub fn g_object_bind_property_full(source: gpointer, source_property: *const gchar, target: gpointer, target_property: *const gchar, flags: GBindingFlags, transform_to: Option<GBindingTransformFunc>, transform_from: Option<GBindingTransformFunc>, user_data: gpointer, notify: glib::GDestroyNotify) -> *mut GBinding;
    pub fn g_object_bind_property_with_closures(source: gpointer, source_property: *const gchar, target: gpointer, target_property: *const gchar, flags: GBindingFlags, transform_to: *mut GClosure, transform_from: *mut GClosure) -> *mut GBinding;
    pub fn g_object_class_find_property(oclass: *mut GObjectClass, property_name: *const gchar) -> *mut GParamSpec;
    pub fn g_object_class_install_properties(oclass: *mut GObjectClass, n_pspecs: guint, pspecs: *mut *mut GParamSpec);
    pub fn g_object_class_install_property(oclass: *mut GObjectClass, property_id: guint, pspec: *mut GParamSpec);
    pub fn g_object_class_list_properties(oclass: *mut GObjectClass, n_properties: guint) -> *mut *mut GParamSpec;
    pub fn g_object_class_override_property(oclass: *mut GObjectClass, property_id: guint, name: *const gchar);
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
    pub fn g_object_dup_data(object: *mut GObject, key: *const gchar, dup_func: Option<glib::GDuplicateFunc>, user_data: gpointer) -> gpointer;
    pub fn g_object_dup_qdata(object: *mut GObject, quark: glib::GQuark, dup_func: Option<glib::GDuplicateFunc>, user_data: gpointer) -> gpointer;
    pub fn g_object_force_floating(object: *mut GObject);
    pub fn g_object_freeze_notify(object: *mut GObject);
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
    pub fn g_object_get_property(object: *mut GObject, property_name: *const gchar, value: *mut GValue);
    pub fn g_object_get_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    pub fn g_object_interface_find_property(g_iface: gpointer, property_name: *const gchar) -> *mut GParamSpec;
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
    pub fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: guint) -> *mut *mut GParamSpec;
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
    pub fn g_object_newv(object_type: GType, n_parameters: guint, parameters: *mut GParameter) -> gpointer;
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
    pub fn g_object_ref(object: gpointer) -> gpointer;
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: gpointer);
    pub fn g_object_replace_data(object: *mut GObject, key: *const gchar, oldval: gpointer, newval: gpointer, destroy: Option<glib::GDestroyNotify>, old_destroy: glib::GDestroyNotify) -> gboolean;
    pub fn g_object_replace_qdata(object: *mut GObject, quark: glib::GQuark, oldval: gpointer, newval: gpointer, destroy: Option<glib::GDestroyNotify>, old_destroy: glib::GDestroyNotify) -> gboolean;
    pub fn g_object_run_dispose(object: *mut GObject);
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
    pub fn g_object_set_data_full(object: *mut GObject, key: *const gchar, data: gpointer, destroy: Option<glib::GDestroyNotify>);
    pub fn g_object_set_property(object: *mut GObject, property_name: *const gchar, value: *const GValue);
    pub fn g_object_set_qdata(object: *mut GObject, quark: glib::GQuark, data: gpointer);
    pub fn g_object_set_qdata_full(object: *mut GObject, quark: glib::GQuark, data: gpointer, destroy: Option<glib::GDestroyNotify>);
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
    pub fn g_object_steal_qdata(object: *mut GObject, quark: glib::GQuark) -> gpointer;
    pub fn g_object_thaw_notify(object: *mut GObject);
    pub fn g_object_unref(object: gpointer);
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
    pub fn g_param_spec_boolean(name: *const gchar, nick: *const gchar, blurb: *const gchar, default_value: gboolean, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_boxed(name: *const gchar, nick: *const gchar, blurb: *const gchar, boxed_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_char(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: i8, maximum: i8, default_value: i8, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_double(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: gdouble, maximum: gdouble, default_value: gdouble, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_enum(name: *const gchar, nick: *const gchar, blurb: *const gchar, enum_type: GType, default_value: gint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_flags(name: *const gchar, nick: *const gchar, blurb: *const gchar, flags_type: GType, default_value: guint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_float(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: gfloat, maximum: gfloat, default_value: gfloat, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_default_value(param: *mut GParamSpec) -> *const GValue;
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_name_quark(param: *mut GParamSpec) -> glib::GQuark;
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_gtype(name: *const gchar, nick: *const gchar, blurb: *const gchar, is_a_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: gint, maximum: gint, default_value: gint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_int64(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: i64, maximum: i64, default_value: i64, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_internal(param_type: GType, name: *const gchar, nick: *const gchar, blurb: *const gchar, flags: GParamFlags) -> gpointer;
    pub fn g_param_spec_long(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: glong, maximum: glong, default_value: glong, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_object(name: *const gchar, nick: *const gchar, blurb: *const gchar, object_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_override(name: *const gchar, overridden: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_param(name: *const gchar, nick: *const gchar, blurb: *const gchar, param_type: GType, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_pointer(name: *const gchar, nick: *const gchar, blurb: *const gchar, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_pool_insert(pool: *mut GParamSpecPool, pspec: *mut GParamSpec, owner_type: GType);
    pub fn g_param_spec_pool_list(pool: *mut GParamSpecPool, owner_type: GType, n_pspecs_p: guint) -> *mut *mut GParamSpec;
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType) -> *mut glib::GList;
    pub fn g_param_spec_pool_lookup(pool: *mut GParamSpecPool, param_name: *const gchar, owner_type: GType, walk_ancestors: gboolean) -> *mut GParamSpec;
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: glib::GQuark, data: gpointer);
    pub fn g_param_spec_set_qdata_full(pspec: *mut GParamSpec, quark: glib::GQuark, data: gpointer, destroy: glib::GDestroyNotify);
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: glib::GQuark) -> gpointer;
    pub fn g_param_spec_string(name: *const gchar, nick: *const gchar, blurb: *const gchar, default_value: *const gchar, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uchar(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: u8, maximum: u8, default_value: u8, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: guint, maximum: guint, default_value: guint, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_uint64(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: u64, maximum: u64, default_value: u64, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_ulong(name: *const gchar, nick: *const gchar, blurb: *const gchar, minimum: gulong, maximum: gulong, default_value: gulong, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_unichar(name: *const gchar, nick: *const gchar, blurb: *const gchar, default_value: gunichar, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
    pub fn g_param_spec_value_array(name: *const gchar, nick: *const gchar, blurb: *const gchar, element_spec: *mut GParamSpec, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_spec_variant(name: *const gchar, nick: *const gchar, blurb: *const gchar, type_: *const glib::GVariantType, default_value: *mut glib::GVariant, flags: GParamFlags) -> *mut GParamSpec;
    pub fn g_param_type_register_static(name: *const gchar, pspec_info: *const GParamSpecTypeInfo) -> GType;
    pub fn g_param_value_convert(pspec: *mut GParamSpec, src_value: *const GValue, dest_value: *mut GValue, strict_validation: gboolean) -> gboolean;
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
    pub fn g_param_values_cmp(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue) -> gint;
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
    pub fn g_signal_accumulator_first_wins(ihint: *mut GSignalInvocationHint, return_accu: *mut GValue, handler_return: *const GValue, dummy: gpointer) -> gboolean;
    pub fn g_signal_accumulator_true_handled(ihint: *mut GSignalInvocationHint, return_accu: *mut GValue, handler_return: *const GValue, dummy: gpointer) -> gboolean;
    pub fn g_signal_add_emission_hook(signal_id: guint, detail: glib::GQuark, hook_func: GSignalEmissionHook, hook_data: gpointer, data_destroy: glib::GDestroyNotify) -> gulong;
    pub fn g_signal_chain_from_overridden(instance_and_params: *mut GValue, return_value: *mut GValue);
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
    pub fn g_signal_connect_closure(instance: gpointer, detailed_signal: *const gchar, closure: *mut GClosure, after: gboolean) -> gulong;
    pub fn g_signal_connect_closure_by_id(instance: gpointer, signal_id: guint, detail: glib::GQuark, closure: *mut GClosure, after: gboolean) -> gulong;
    pub fn g_signal_connect_data(instance: gpointer, detailed_signal: *const gchar, c_handler: GCallback, data: gpointer, destroy_data: GClosureNotify, connect_flags: GConnectFlags) -> gulong;
    pub fn g_signal_connect_object(instance: gpointer, detailed_signal: *const gchar, c_handler: GCallback, gobject: gpointer, connect_flags: GConnectFlags) -> gulong;
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: glib::GQuark, ...);
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
    pub fn g_signal_emitv(instance_and_params: *mut GValue, signal_id: guint, detail: glib::GQuark, return_value: GValue);
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> gulong;
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
    pub fn g_signal_handlers_block_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> guint;
    pub fn g_signal_handlers_destroy(instance: gpointer);
    pub fn g_signal_handlers_disconnect_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> guint;
    pub fn g_signal_handlers_unblock_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: glib::GQuark, closure: *mut GClosure, func: gpointer, data: gpointer) -> guint;
    pub fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint, detail: glib::GQuark, may_be_blocked: gboolean) -> gboolean;
    pub fn g_signal_list_ids(itype: GType, n_ids: guint) -> *mut guint;
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
    pub fn g_signal_new(signal_name: *const gchar, itype: GType, signal_flags: GSignalFlags, class_offset: guint, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) -> guint;
    pub fn g_signal_new_class_handler(signal_name: *const gchar, itype: GType, signal_flags: GSignalFlags, class_handler: GCallback, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) -> guint;
    pub fn g_signal_newv(signal_name: *const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: *mut GClosure, accumulator: Option<GSignalAccumulator>, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, param_types: *mut GType) -> guint;
    pub fn g_signal_override_class_closure(signal_id: guint, instance_type: GType, class_closure: *mut GClosure);
    pub fn g_signal_override_class_handler(signal_name: *const gchar, instance_type: GType, class_handler: GCallback);
    pub fn g_signal_parse_name(detailed_signal: *const gchar, itype: GType, signal_id_p: guint, detail_p: glib::GQuark, force_detail_quark: gboolean) -> gboolean;
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: glib::GQuark);
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
    pub fn g_source_set_closure(source: *mut glib::GSource, closure: *mut GClosure);
    pub fn g_source_set_dummy_callback(source: *mut glib::GSource);
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: *mut GTypePlugin);
    pub fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: *const GInterfaceInfo);
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
    pub fn g_type_check_instance_cast(instance: *mut GTypeInstance, iface_type: GType) -> *mut GTypeInstance;
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
    pub fn g_type_check_instance_is_fundamentally_a(instance: *mut GTypeInstance, fundamental_type: GType) -> gboolean;
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
    pub fn g_type_check_value_holds(value: *mut GValue, type_: GType) -> gboolean;
    pub fn g_type_children(type_: GType, n_children: guint) -> *mut GType;
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: gint);
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
    pub fn g_type_class_peek(type_: GType) -> gpointer;
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
    pub fn g_type_class_ref(type_: GType) -> gpointer;
    pub fn g_type_class_unref(g_class: gpointer);
    pub fn g_type_class_unref_uncached(g_class: gpointer);
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
    pub fn g_type_default_interface_unref(g_iface: gpointer);
    pub fn g_type_depth(type_: GType) -> guint;
    pub fn g_type_ensure(type_: GType);
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
    pub fn g_type_from_name(name: *const gchar) -> GType;
    pub fn g_type_fundamental(type_id: GType) -> GType;
    pub fn g_type_fundamental_next() -> GType;
    pub fn g_type_get_instance_count(type_: GType) -> gint;
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
    pub fn g_type_get_qdata(type_: GType, quark: glib::GQuark) -> gpointer;
    pub fn g_type_get_type_registration_serial() -> guint;
    pub fn g_type_init();
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
    pub fn g_type_instance_get_private(instance: *mut GTypeInstance, private_type: GType) -> gpointer;
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
    pub fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) -> *mut GTypePlugin;
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
    pub fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: guint) -> *mut GType;
    pub fn g_type_interfaces(type_: GType, n_interfaces: guint) -> *mut GType;
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
    pub fn g_type_module_add_interface(module: *mut GTypeModule, instance_type: GType, interface_type: GType, interface_info: *const GInterfaceInfo);
    pub fn g_type_module_register_enum(module: *mut GTypeModule, name: *const gchar, const_static_values: *const GEnumValue) -> GType;
    pub fn g_type_module_register_flags(module: *mut GTypeModule, name: *const gchar, const_static_values: *const GFlagsValue) -> GType;
    pub fn g_type_module_register_type(module: *mut GTypeModule, parent_type: GType, type_name: *const gchar, type_info: *const GTypeInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
    pub fn g_type_module_unuse(module: *mut GTypeModule);
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
    pub fn g_type_name(type_: GType) -> *const gchar;
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
    pub fn g_type_parent(type_: GType) -> GType;
    pub fn g_type_plugin_complete_interface_info(plugin: *mut GTypePlugin, instance_type: GType, interface_type: GType, info: *mut GInterfaceInfo);
    pub fn g_type_plugin_complete_type_info(plugin: *mut GTypePlugin, g_type: GType, info: *mut GTypeInfo, value_table: *mut GTypeValueTable);
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
    pub fn g_type_qname(type_: GType) -> glib::GQuark;
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
    pub fn g_type_register_dynamic(parent_type: GType, type_name: *const gchar, plugin: *mut GTypePlugin, flags: GTypeFlags) -> GType;
    pub fn g_type_register_fundamental(type_id: GType, type_name: *const gchar, info: *const GTypeInfo, finfo: *const GTypeFundamentalInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_register_static(parent_type: GType, type_name: *const gchar, info: *const GTypeInfo, flags: GTypeFlags) -> GType;
    pub fn g_type_register_static_simple(parent_type: GType, type_name: *const gchar, class_size: guint, class_init: GClassInitFunc, instance_size: guint, instance_init: GInstanceInitFunc, flags: GTypeFlags) -> GType;
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
    pub fn g_type_set_qdata(type_: GType, quark: glib::GQuark, data: gpointer);
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
    pub fn g_value_array_append(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
    pub fn g_value_array_free(value_array: *mut GValueArray);
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
    pub fn g_value_array_insert(value_array: *mut GValueArray, index_: guint, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
    pub fn g_value_array_prepend(value_array: *mut GValueArray, value: *const GValue) -> *mut GValueArray;
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
    pub fn g_value_array_sort(value_array: *mut GValueArray, compare_func: glib::GCompareFunc) -> *mut GValueArray;
    pub fn g_value_array_sort_with_data(value_array: *mut GValueArray, compare_func: glib::GCompareDataFunc, user_data: gpointer) -> *mut GValueArray;
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
    pub fn g_value_dup_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
    pub fn g_value_get_char(value: *const GValue) -> gchar;
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
    pub fn g_value_get_enum(value: *const GValue) -> gint;
    pub fn g_value_get_flags(value: *const GValue) -> guint;
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
    pub fn g_value_get_int(value: *const GValue) -> gint;
    pub fn g_value_get_int64(value: *const GValue) -> i64;
    pub fn g_value_get_long(value: *const GValue) -> glong;
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_get_schar(value: *const GValue) -> i8;
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
    pub fn g_value_get_uchar(value: *const GValue) -> u8;
    pub fn g_value_get_uint(value: *const GValue) -> guint;
    pub fn g_value_get_uint64(value: *const GValue) -> u64;
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
    pub fn g_value_get_variant(value: *const GValue) -> *mut glib::GVariant;
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
    pub fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform);
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
    pub fn g_value_set_int64(value: *mut GValue, v_int64: i64);
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
    pub fn g_value_set_schar(value: *mut GValue, v_char: i8);
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: u8);
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: u64);
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut glib::GVariant);
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut glib::GVariant);
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
    pub fn g_value_unset(value: *mut GValue);
    pub fn g_weak_ref_clear(weak_ref: GWeakRef);
    pub fn g_weak_ref_get(weak_ref: GWeakRef) -> gpointer;
    pub fn g_weak_ref_init(weak_ref: GWeakRef, object: gpointer);
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
